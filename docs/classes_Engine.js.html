<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: classes/Engine.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: classes/Engine.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * The Engine is responsible for calling the `update` and `render` methods
  at fixed time intervals, determined by the `fps` property
 */
export class Engine {
  /**
   * Game update function to call before rendering each frame
   * @type {function}
   */
  #update

  /**
   * Render function to call each frame
   * @type {function}
   */
  #render

  /**
   * Fixed time step in seconds. `update` &amp; `render` are called at this
   * frequency
   * @type {number}
   */
  #timeStep

  /**
   * Most recent time the cycle was run
   * `DOMHighResTimeStamp`, measured in milliseconds.
   * @type {number}
   */
  #mostRecentTime = 0

  /**
   * Time the last frame was rendered.
   * `DOMHighResTimeStamp`, measured in milliseconds.
   * @type {number}
   */
  #lastFrameTime = window.performance.now()

  /**
   * Time elapsed between frames in seconds
   * @type {number}
   */
  #accumulatedTime = 0

  /**
   * Has the `update` function been called since last cycle?
   * `false` if not enough time has passed.
   * Prevents rendering when no update has occurred.
   * @type {boolean}
   */
  #updated = false

  /**
  * Is the engine running or stopped?
  * Determines if the frame function should keep being called by
  `requestAnimationFrame`
  * @type {boolean}
  */
  #isRunning = false

  /**
   * @typedef {object} EngineConfig
   * @property {function} update - Called before rendering
   * @property {function} render - Called after updating
   * @property {number} fps - Frames Per Second
   */
  /**
   *
   * @param {EngineConfig} config
   */
  constructor({ update, render, fps }) {
    this.#update = update
    this.#render = render
    this.#timeStep = 1 / fps
  }

  /**
   * Start the game loop. Start calling update and render at set frequency
   */
  start() {
    this.#isRunning = true
    requestAnimationFrame(this.#frame)
  }

  /**
   * Stop the game loop. Update and render will no longer be called
   */
  stop() {
    this.#isRunning = false
  }

  /**
   * Calculates the time between frames
   * It is capped at 1 second, in case the user switches tabs for a long time,
   * so that the update function isn't called over and over before rendering
   * @param {number} currentTime - In milliseconds
   * @param {number} previousTime - In milliseconds
   * @returns {number} Time in seconds between frames, capped at 1 second
   */
  #calculateAccumulatedTime(currentTime, previousTime) {
    const deltaInSeconds = (currentTime - previousTime) / 1000
    const cappedDelta = Math.min(1, deltaInSeconds)
    return cappedDelta
  }

  /**
   * This is the callback to requestAnimationFrame.
   * Checks how much time has passed after the last call,
   * calls the update function as many times as necessary,
   * and then calls the render function if update has been called
   * @returns {void}
   */
  #frame = () => {
    if (!this.#isRunning) return

    this.#mostRecentTime = window.performance.now()
    this.#accumulatedTime =
      this.#accumulatedTime +
      this.#calculateAccumulatedTime(this.#mostRecentTime, this.#lastFrameTime)

    /*
    We only update and render when the browser is ready. To ensure the game runs
    at the same speed regardless of machine, we need to:
      * Only update game if enough time has elapsed.
      *  Keep updating the game if more than a time step's worth of time has
          elapsed
    */
    while (this.#accumulatedTime > this.#timeStep) {
      this.#accumulatedTime -= this.#timeStep
      this.#update(this.#timeStep)
      this.#updated = true
    }

    // Only render if the game has updated
    if (this.#updated) {
      this.#render(this.#accumulatedTime)
      this.#updated = false
    }

    this.#lastFrameTime = this.#mostRecentTime
    requestAnimationFrame(this.#frame)
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BrushProjectile.html">BrushProjectile</a></li><li><a href="Controller.html">Controller</a></li><li><a href="Engine.html">Engine</a></li><li><a href="Game.html">Game</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="GameWorld.html">GameWorld</a></li><li><a href="GoalObject.html">GoalObject</a></li><li><a href="Level.html">Level</a></li><li><a href="Platform.html">Platform</a></li><li><a href="Player.html">Player</a></li><li><a href="Renderer.html">Renderer</a></li><li><a href="Sprite.html">Sprite</a></li><li><a href="Treat.html">Treat</a></li></ul><h3>Global</h3><ul><li><a href="global.html#availableLevels">availableLevels</a></li><li><a href="global.html#controller">controller</a></li><li><a href="global.html#currentLevel">currentLevel</a></li><li><a href="global.html#decrementLevel">decrementLevel</a></li><li><a href="global.html#deleteDataBtn">deleteDataBtn</a></li><li><a href="global.html#deleteSavedData">deleteSavedData</a></li><li><a href="global.html#engine">engine</a></li><li><a href="global.html#game">game</a></li><li><a href="global.html#gameOver">gameOver</a></li><li><a href="global.html#handleInputEvent">handleInputEvent</a></li><li><a href="global.html#handleResize">handleResize</a></li><li><a href="global.html#helpBtn">helpBtn</a></li><li><a href="global.html#helpToggle">helpToggle</a></li><li><a href="global.html#incrementLevel">incrementLevel</a></li><li><a href="global.html#initializeLocalData">initializeLocalData</a></li><li><a href="global.html#nextLevelBtn">nextLevelBtn</a></li><li><a href="global.html#prevLevelBtn">prevLevelBtn</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderer">renderer</a></li><li><a href="global.html#restart">restart</a></li><li><a href="global.html#restartBtn">restartBtn</a></li><li><a href="global.html#saveLevelData">saveLevelData</a></li><li><a href="global.html#secondsToTimerString">secondsToTimerString</a></li><li><a href="global.html#setLevel">setLevel</a></li><li><a href="global.html#setupLevelButtons">setupLevelButtons</a></li><li><a href="global.html#showPersonalBest">showPersonalBest</a></li><li><a href="global.html#unlockedLevels">unlockedLevels</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateTimer">updateTimer</a></li><li><a href="global.html#updateTreats">updateTreats</a></li><li><a href="global.html#updateUnlockedLevels">updateUnlockedLevels</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri May 13 2022 01:00:07 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
